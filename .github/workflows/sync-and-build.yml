name: Sync Fork and Build Docker Image

on:
  # 1. 定时触发：每天 UTC 时间 0 点执行一次同步
  schedule:
    - cron: '0 0 * * *'
  
  # 2. 手动触发：允许您在 GitHub Actions 页面手动运行此工作流
  workflow_dispatch:

  # 3. Push 触发：当有代码推送到 master 分支时，触发构建和推送作业
  push:
    branches:
      - master
    paths-ignore:
      - 'README.md'
      - '.gitignore'

jobs:
  # 作业一：同步上游仓库
  sync_fork:
    runs-on: ubuntu-latest
    # 仅在定时或手动触发时运行此作业
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout the repository
        uses: actions/checkout@v4
        with:
          # 需要一个有写权限的 PAT (Personal Access Token) 来推送更新
          token: ${{ secrets.PAT_TOKEN }}
          fetch-depth: 0  # 获取完整的历史记录

      - name: 配置 Git 用户信息
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: 安全同步上游仓库 (保护 .github 目录)
        run: |
          echo "🔄 开始安全同步流程..."
          
          # 检查当前状态
          echo "📊 当前仓库状态:"
          git status --porcelain
          
          # 添加上游远程仓库 (如果不存在)
          if ! git remote get-url upstream >/dev/null 2>&1; then
            echo "➕ 添加上游远程仓库..."
            git remote add upstream https://github.com/su-kaka/gcli2api.git
          else
            echo "✅ 上游远程仓库已存在"
          fi
          
          # 获取上游更新
          echo "📥 获取上游更新..."
          git fetch upstream master
          
          # 检查是否需要更新
          LOCAL_COMMIT=$(git rev-parse HEAD)
          UPSTREAM_COMMIT=$(git rev-parse upstream/master)
          
          if [ "$LOCAL_COMMIT" = "$UPSTREAM_COMMIT" ]; then
            echo "✅ 仓库已是最新版本，无需同步"
            exit 0
          fi
          
          echo "🔍 检测到上游更新，开始同步..."
          echo "本地提交: $LOCAL_COMMIT"
          echo "上游提交: $UPSTREAM_COMMIT"
          
          # 备份 .github 目录
          echo "�️ 备份 .github 目录..."
          cp -r .github /tmp/github-backup
          
          # 创建临时分支并应用上游更改
          echo "🌿 创建临时分支..."
          TEMP_BRANCH="temp-sync-$(date +%Y%m%d-%H%M%S)"
          git checkout -b $TEMP_BRANCH
          
          # 使用简单的方式：直接checkout上游文件但排除.github目录
          echo "📝 同步上游文件 (排除 .github 目录)..."
          
          # 获取上游仓库中所有文件列表，但排除 .github 目录和 Dockerfile
          git ls-tree -r --name-only upstream/master | grep -v -E '^\.github/|^Dockerfile$|^docker-compose\.yml$' > /tmp/files_to_sync
          
          if [ -s /tmp/files_to_sync ]; then
            # 逐个checkout上游文件
            while IFS= read -r file; do
              # 创建目录结构（如果需要）
              mkdir -p "$(dirname "$file")" 2>/dev/null || true
              # checkout文件
              git show upstream/master:"$file" > "$file" 2>/dev/null || echo "⚠️ 无法同步文件: $file"
            done < /tmp/files_to_sync
            
            echo "� 添加同步的文件到暂存区..."
            git add .
            
            # 检查是否有更改
            if git diff --staged --quiet; then
              echo "ℹ️ 没有检测到文件更改"
            else
              echo "💾 提交同步更改..."
              git commit -m "sync: 同步上游仓库更改 (保护 .github 目录)"
            fi
          else
            echo "ℹ️ 没有找到需要同步的文件"
          fi
          
          # 恢复 .github 目录
          echo "� 恢复 .github 目录..."
          rm -rf .github
          cp -r /tmp/github-backup .github
          
          # 切换回 master 分支
          echo "� 切换回 master 分支..."
          git checkout master
          
          # 合并临时分支的更改
          echo "🔗 合并同步更改..."
          git merge $TEMP_BRANCH --no-edit
          
          # 清理临时分支和文件
          echo "🧹 清理临时文件..."
          git branch -D $TEMP_BRANCH
          rm -f /tmp/files_to_sync
          rm -rf /tmp/github-backup
          
          # 验证关键文件
          echo "✅ 验证关键文件完整性..."
          if [ ! -f ".github/workflows/sync-and-build.yml" ]; then
            echo "❌ 错误: 工作流文件丢失!"
            exit 1
          fi
          
          echo "📊 最终状态检查:"
          git status --porcelain
          
          # 推送更新
          echo "🚀 推送更新到远程仓库..."
          git push origin master
          
          echo "🎉 同步完成! .github 目录已受到保护"

  # 作业二：构建并推送 Docker 镜像
  build_and_push:
    runs-on: ubuntu-latest
    # 仅在代码被推送到 master 分支时运行此作业
    # (同步作业成功后会产生一次 push，从而触发此作业)
    if: github.event_name == 'push'
    permissions:
      contents: read
      packages: write # 需要 'packages' 的写权限来推送镜像到 GHCR
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }} # 自动获取您的 GitHub 用户名
          password: ${{ secrets.GITHUB_TOKEN }}   # 使用 GitHub 自动提供的 GITHUB_TOKEN

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/gcli2api
          tags: |
            # 为镜像添加两个标签:
            # 1. 具体版本号 (commit SHA)
            type=sha
            # 2. 当推送到默认分支 (master) 时，添加 'latest' 标签
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
